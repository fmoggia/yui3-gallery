<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>js&#x2F;datatable-paginator-class.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Y.DataTable.Paginator.html">Y.DataTable.Paginator</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/datatable.html">datatable</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: js&#x2F;datatable-paginator-class.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
  Defines a Y.DataTable class extension to add capability to support a Paginator View-Model and allow
   paging of actively displayed data within the DT instance.

  Works with either client-side pagination (i.e. local data, usually in form of JS Array) or
   in conjunction with remote server-side pagination, via either DataSource or ModelSync.REST.

  Allows for dealing with sorted data, wherein the local data is sorted in place, and in the case of remote data the &quot;sortBy&quot; attribute is passed to the remote server.

 &lt;h4&gt;Usage&lt;&#x2F;h4&gt;

        var dtable = new Y.DataTable({
            columns:    [ &#x27;firstName&#x27;,&#x27;lastName&#x27;,&#x27;state&#x27;,&#x27;age&#x27;, &#x27;grade&#x27; ],
            data:       enrollment.records,
            scrollable: &#x27;y&#x27;,
            height:     &#x27;450px&#x27;,
            paginator:  new PaginatorView({
                model:  new PaginatorModel({itemsPerPage:50, page:1})
            })

        });

 &lt;h4&gt;Client OR Server Pagination&lt;&#x2F;h4&gt;

 A determination of whether the source of &#x60;data&#x60; is either &quot;local&quot; data (i.e. a Javascript Array or Y.ModelList), or is
 provided from a server (either DataSource or ModelSync.REST) is made in the method [_bindPaginator](#method__bindPaginator).
 We use a &quot;duck-type&quot; evaluation, which may not be completely robust, but has worked so far in testing.

 For remote data, the initial call to &#x60;.set(&#x27;data&#x27;,...)&#x60; and&#x2F;or &#x60;data.load(...)&#x60; returns a null array, of zero length, while
 the request is being retrieved.  We use this fact to discern that it is not &quot;local&quot; data.  Then we evaluate whether the
 &#x60;datasource&#x60; plugin exists, and if so we assume the source is DataSource, and set &#x60;_pagDataSrc:&#x27;ds&#x27;&#x60;.  Otherwise, if the
 &#x60;data&#x60; property (i.e. the ModelList) contains an attribute &#x60;totalRecs&#x60; we expect that data will be retrieved via ModelSync.REST
 and set &#x60;_pagDataSrc:&#x27;mlist&#x27;&#x60;.

 &lt;h4&gt;Loading the &#x60;data&#x60; For a Page&lt;&#x2F;h4&gt;
 Once the &quot;source of data&quot; is known, the method [processPageRequest](#method_processPageRequest) fires on a &#x60;pageChange&#x60;.

 For the case of &quot;local data&quot;, i.e. where &#x60;_pagDataSrc:&#x27;local&#x27;&#x60;, the existing buffer of data is sliced according to the pagination
 state, and the data is loaded silently, and &#x60;this.syncUI()&#x60; is fired to refresh the DT.

 The case of &quot;remote data&quot; (from a server) is actually more straightforward.  This extension DOES NOT &quot;cache&quot; pages for remote
 data, it simply inserts the full returned data into the DT.  So as a consequence, a pagination state change for remote data
 involves a simple request sent to the server source (either DataSource or ModelSync.REST) and the response results are
 loaded in the DT.



  @module datatable
  @class Y.DataTable.Paginator
  @extensionfor DataTable
  @extends Y.DataTable
  @version 1.0.1
  @since 3.6.0
  @author Todd Smith

 **&#x2F;
function DtPaginator() {}


DtPaginator.ATTRS = {

    &#x2F;**
     * Adds a paginator view (specifically, Y.PaginatorView) instance to the DataTable.
     *
     * @attribute paginator
     * @type Y.View
     * @default null
     *&#x2F;
    paginator:  {
        value : null,
        setter: &#x27;_setPaginator&#x27;
    }
}


Y.mix( DtPaginator.prototype, {
    &#x2F;**
     * Holder for the &quot;original&quot; un-paged data that the DataTable was based upon.
     *
     * This property is stored as an Array, from the original &quot;data&quot; ModelList.
     * For remote data, it is used as-is.
     * For local data, is sliced as needed to re-set each data Page.
     *
     * Populated in _bindPaginator and utilized in processPageRequest
     *
     * @property _mlistArray
     * @type Array
     * @default null
     * @static
     * @since 3.6.0
     * @protected
     *&#x2F;
    _mlistArray: null,


    &#x2F;**
     * Placeholder for a text flag indicating the duck-typed source of data for this
     *  DataTable, this is set in &#x60;_bindPaginator&#x60; to either of &#x27;ds&#x27;, &#x27;mlist&#x27; or &#x27;local&#x27;
     *
     *  Populated in _bindPaginator
     *  Utilized in processPageRequest
     *
     * @property _pagDataSrc
     * @type String
     * @default null
     * @static
     * @since 3.6.0
     * @protected
     *&#x2F;
    _pagDataSrc: null,


    &#x2F;**
     * A convenience property (which is identical to the attribute &#x60;paginator&#x60;) for use by the user.
     *
     * @property paginator
     * @type {Y.PaginatorView|View}
     * @default null
     * @public
     * @since 3.6.0
     *&#x2F;
    paginator: null,

&#x2F;*----------------------------------------------------------------------------------------------------------*&#x2F;
&#x2F;*                  L I F E - C Y C L E    M E T H O D S                                                    *&#x2F;
&#x2F;*----------------------------------------------------------------------------------------------------------*&#x2F;

   &#x2F;**
    * This initializer sets up the listeners related to the original DataTable instance and
    *  also related to the underlying &quot;data&quot; attribute the DT is based upon.
    *
    * @method initializer
    * @private
    * @return this
    * @chainable
    *&#x2F;
    initializer: function(){
       &#x2F;&#x2F;
       &#x2F;&#x2F; Setup listeners on DT&#x27;s bindUI method and on &#x27;data&#x27; loads
       &#x2F;&#x2F;
        this._eventHandles.paginator = [];
        this._eventHandles.paginator.push( Y.Do.after( this._bindPaginator, this, &#x27;_bindUI&#x27;, this) );
        this._eventHandles.paginator.push( this.get(&#x27;data&#x27;).after([&quot;load&quot;,&quot;change&quot;,&quot;reset&quot;,&quot;add&quot;,&quot;remove&quot;], Y.bind(this._bindPaginator,this)) );

       &#x2F;&#x2F;
       &#x2F;&#x2F; Had to do this, specifically for DataSource ... (no better way?)
       &#x2F;&#x2F;   since DataSource is a plugin, it may not be plugged when DT instantiates,
       &#x2F;&#x2F;   so this captures the .set(&#x27;data&#x27;,...) event, and redirects to _bindPaginator
       &#x2F;&#x2F;
        this._eventHandles.paginator.push( Y.Do.after( this._afterSetData, this, &#x27;_setData&#x27;, this) );

       &#x2F;&#x2F; Try to determine when DT is finished rendering records, this is hacky .. but seems to work
        this._eventHandles.paginator.push( this.after( &#x27;renderView&#x27;, this._notifyRender) );

        return this
    },

    &#x2F;**
     * Destructor to clean up listener event handlers and the internal storage buffer.
     *
     * @method destructor
     * @public
     *&#x2F;
    destructor: function () {
        Y.Array.each( this._eventHandles.paginator,function(item){
            item.detach();
        });
        this._mlistArray = null;
        this._subscr = null;
    },


&#x2F;*----------------------------------------------------------------------------------------------------------*&#x2F;
&#x2F;*                  P U B L I C      M E T H O D S                                                          *&#x2F;
&#x2F;*----------------------------------------------------------------------------------------------------------*&#x2F;

    &#x2F;**
     * Method to re-initialize the original data, mostly targeted at local data
     *  when a new &#x27;data&#x27; is set, untested.
     *
     * @method dataReset
     * @param {Array|ModelList} data Data to be reset to ... either as a JS Array or a Y.ModelList
     * @public
     * @returns nothing
     * @beta
     *&#x2F;
    dataReset: function(data){
        if ( data instanceof Y.ModelList ) {
            this._mlistArray = [];
            data.each(function(model){
                this._mlistArray.push( model.toJSON() );
            },this);
        } else if (Y.Lang.isArray(data) ) {
            this._mlistArray = [];
            this._mlistArray = data;
        }
    },

    &#x2F;**
     * Primary workhorse method that is fired when the Paginator &quot;page&quot; changes,
     *   and returns a new subset of data for the DT
     *   or sends a new request to a remote source to populate the DT
     *
     *  @method processPageRequest
     *  @param  {Integer} page_no Current page number to change to
     *  @param  {Object} pag_state Pagination state object (this is NOT populated in local .. non-server type pagination) including;
     *      @param {Integer} pag_state.indexStart Starting index returned from server response
     *      @param {Integer} pag_state.numRecs Count of records returned from the response
     *  @public
     *  @returns nothing
     *&#x2F;
    processPageRequest: function(page_no, pag_state) {
        var rdata = this._mlistArray,
            pagv  = this.get(&#x27;paginator&#x27;),
            pagm  = pagv.get(&#x27;model&#x27;),
            rpp   = pagm.get(&#x27;itemsPerPage&#x27;);

        var istart, iend, nitem;
    &#x2F;&#x2F;
    &#x2F;&#x2F;  Get paginator indices
    &#x2F;&#x2F;
        if ( pag_state ) {
            istart = pag_state.itemIndexStart;
            iend   = pag_state.itemIndexEnd;
        } else {
            &#x2F;&#x2F; usually here on first pass thru, when paginator initiates ...
            istart = ( page_no - 1 ) * rpp;
            iend = istart + rpp;
            iend = ( iend &gt; rdata.length ) ? rdata.length : iend;
            nitem = iend - istart + 1;
        }

    &#x2F;&#x2F;
    &#x2F;&#x2F;  This is the main guts of retrieving the records,
    &#x2F;&#x2F;    we already figured out if this was &#x27;local&#x27; or &#x27;server&#x27; based.
    &#x2F;&#x2F;
    &#x2F;&#x2F;   Now, process this page request thru either local data array slicing or
    &#x2F;&#x2F;    simply firing off a remote server request ...
    &#x2F;&#x2F;
        switch(this._pagDataSrc) {

            case &#x27;ds&#x27;:

                var ds,qsTmpl,qs;

                ds = this.datasource || this.datasourcepag;

                qsTmpl  = ds.get(&#x27;queryStringTemplate&#x27;);
                qs      = Y.Lang.sub( qsTmpl, {
                            startIndex: istart,
                            numRecs:    rpp,
                            sortBy:     Y.JSON.stringify( this.get(&#x27;sortBy&#x27;) || {} ) || null
                        });

                ds.load({  request: qs });
                break;

            case &#x27;mlist&#x27;:
            case &#x27;rest&#x27;:

                this.get(&#x27;data&#x27;).load({
                    startIndex: istart,
                    numRecs:    rpp,
                    sortBy:     Y.JSON.stringify( this.get(&#x27;sortBy&#x27;) || {} ) || null
                });

                break;

            default:

                var data_new = rdata.slice(istart,iend);
                this.data.reset( data_new, {silent:true} );
                this.syncUI();

        }

        this.fire(&#x27;pageupdate&#x27;,{ state:pag_state, view:pagv });
    },


&#x2F;*----------------------------------------------------------------------------------------------------------*&#x2F;
&#x2F;*                  P R I V A T E    M E T H O D S                                                          *&#x2F;
&#x2F;*----------------------------------------------------------------------------------------------------------*&#x2F;

    &#x2F;**
     * Listener hooked to the original DT&#x27;s &quot;syncUI&quot; event, only stores the ModelList for
     *  the DT on the first pass through.
     *
     *  For server-generated data, this method determines the server type (DataSource or ModelSync.REST)
     *   and sets the property flag _pagDataSrc to either &#x27;ds&#x27; or &#x27;mlist&#x27;
     *
     *
     * @method _bindPaginator
     * @since 3.6.0
     * @private
     * @returns true or false
     *&#x2F;
    _bindPaginator: function() {
        &#x2F;&#x2F;
        &#x2F;&#x2F; First time through, before DT ModelList has been read,
        &#x2F;&#x2F;  store the &quot;base&quot; ModelList ....
        &#x2F;&#x2F;
        &#x2F;&#x2F; Otherwise ... just pass thru this
        &#x2F;&#x2F;
        if ( !this._mlistArray &amp;&amp; this.data &amp;&amp; this.data.size &amp;&amp; this.data.size()&gt;0 ) {

            &#x2F;&#x2F; Store the &quot;base&quot; ModelList internally ...
            this._mlistArray = [];
            this.data.each(function(model){
                this._mlistArray.push( model.toJSON() );
            },this);

            &#x2F;&#x2F;
            &#x2F;&#x2F; If paginator is connected, push the total No. of Rows
            &#x2F;&#x2F;   for the paginator, render it, and set a &quot;pageChange&quot; listener
            &#x2F;&#x2F;
            var pag     = this.paginator,
                pgmodel = pag.get(&#x27;model&#x27;);

            if ( pag &amp;&amp; pgmodel ) {

                var totalRecs = null;

                &#x2F;&#x2F; Duck checking for local &#x2F; array data ...
                if ( this._mlistArray.length &gt; 0) {
                    this._pagDataSrc = &#x27;array&#x27;;
                    totalRecs = this._mlistArray.length;
                }

                &#x2F;&#x2F; Duck checking for ModelList &#x2F; REST ...
                var mlTotalRecs = (this.data.getAttrs().totalRecs) ? this.data.get(&#x27;totalRecs&#x27;) : null;
                if ( mlTotalRecs ) {
                    this._pagDataSrc = &#x27;mlist&#x27;;
                    totalRecs = mlTotalRecs;
                }

                &#x2F;&#x2F; check if DS ... if so, get the totalrecords from the DS
                &#x2F;&#x2F;  ( datasourcepag was the NS for a testing plugin extension, leave it here for now ...)

                if ( this.datasource || this.datasourcepag ) {
                    var dsds;
                    if ( this.datasource ) {
                        dsds = this.datasource || null;
                    } else {
                        dsds = this.datasourcepag || null;
                    }

                    if ( dsds &amp;&amp; dsds.get(&#x27;state&#x27;) &amp;&amp; dsds.get(&#x27;state&#x27;) &amp;&amp; dsds.get(&#x27;state&#x27;).totalItems ) {
                        this._pagDataSrc = &#x27;ds&#x27;;
                        totalRecs = dsds.get(&#x27;state&#x27;).totalItems;
                    }
                }

                if ( !totalRecs ) return false;

            &#x2F;&#x2F;
            &#x2F;&#x2F;  Setup the Paginator Model and View ...
            &#x2F;&#x2F;
                this.paginator = pag;

                pgmodel.set(&#x27;totalItems&#x27;, totalRecs, {silent:true});
                pag.set(&#x27;dt&#x27;,this);
                pag.render();

                pgmodel.set(&#x27;page&#x27;,0);
                pag.on(&#x27;pageChange&#x27;,this._pageListener, this);
                pgmodel.set(&#x27;page&#x27;,1);

                this.processPageRequest(pgmodel.get(&#x27;page&#x27;));

                this.fire(&#x27;paginatorSetup&#x27;, {model:pgmodel, view:pag} );
            }
        }
    },

    &#x2F;**
     * Listener that fires when the Model&#x27;s &#x27;pageChange&#x27; fires, this extracts the current page from the state object and then
     *  hooks up the processPageRequest method.
     *
     * @method _pageListener
     * @param {Object} o which contains a &#x60;state&#x60; object containing the &#x60;Model.getAttrs()&#x60; attributes
     * @private
     *&#x2F;
    _pageListener: function(o){
        if (o.state.page) {
            this.processPageRequest(o.state.page, o.state);
        }
    },

    &#x2F;**
     * This is a setter for the &#x27;paginator&#x27; attribute, primarily to set the public property &#x60;paginator&#x60; to the
     * attribute value.
     *
     * @method _setPaginator
     * @param {PaginatorView|View} val The PaginatorView instance to set
     * @return {*}
     * @private
     *&#x2F;
    _setPaginator : function(val){
        if ( !val ) return;
        this.paginator = val;
        return val;
    },

    &#x2F;**
     * A method that fires after the DataTable &#x60;renderView&#x60; method completes, that is *approximately* when
     * the DataTable has finished rendering.
     *
     * @method _notifyRender
     * @private
     *&#x2F;
    _notifyRender: function() {
        this.fire(&#x27;render&#x27;);
    },

    &#x2F;**
     * A connector method that will re-bind the Paginator instance to this DataTable after an underlying
     * change to &quot;data&quot; (via &#x60;*:change&#x60;, &#x60;*:reset&#x60;, &#x60;*:add&#x60;, &#x60;*:remove&#x60; events)
     *
     * @method _afterSetData
     * @param {EventFacade} e
     * @private
     *&#x2F;
    _afterSetData:  function(e){
        &#x2F;&#x2F;console.log(&#x27;aftersetdata ... data.size=&#x27; + this.data.size() );
        if ( this.data.size &amp;&amp; this.data.size()&gt;0 )
            this._bindPaginator();
    }

    &#x2F;**
     * Fires after the DataTable &#x27;renderView&#x27; event fires
     * @event render
     *&#x2F;

    &#x2F;**
     * Fires after the DataTable-Paginator updates the page data and&#x2F;or sends the remote request for more data
     * @event pageupdate
     * @param {Object} pagStatus containing following;
     *  @param {Object} pagStatus.pag_state Of Paginator Model &#x60;getAttrs()&#x60; as an Object
     *  @param {View} pagStatus.view Instance of the Paginator View
     *&#x2F;

    &#x2F;**
     * Fires after the DataTable-Paginator has setup properly, rendered the View and is ready to accept page changes
     * @event paginatorSetup
     * @param {Object} pagObj Containing following;
     *  @param {Model} pagObj.model Instance of Paginator Model
     *  @param {View} pagObj.view Instance of the Paginator View
     *&#x2F;

});

Y.DataTable.Paginator = DtPaginator;
Y.Base.mix(Y.DataTable, [Y.DataTable.Paginator]);

&#x2F;&#x2F; requires: &quot;datatable-base&quot;, &quot;base-build&quot;, &quot;event-custom&quot;

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
