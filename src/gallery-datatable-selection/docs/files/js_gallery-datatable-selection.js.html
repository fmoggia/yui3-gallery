<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>js&#x2F;gallery-datatable-selection.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Y.DataTable.Selection.html">Y.DataTable.Selection</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/DataTable.html">DataTable</a></li>
            
                <li><a href="..&#x2F;modules/Selection.html">Selection</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: js&#x2F;gallery-datatable-selection.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 A class extension for DataTable that adds &quot;highlight&quot; and &quot;select&quot; actions via mouse selection.
 The extension works in either &quot;cell&quot; mode or &quot;row&quot; mode (set via attribute [selectionMode](#attr_selectionMode)).

 Highlighting is controlled by the [highlightMode](#attr_highlightMode) attribute (either &quot;cell&quot; or &quot;row&quot;).
 (Highlighting provides a &quot;mouseover&quot; indication only).

 Selection is provided bia &quot;click&quot; listeners.

 This extension includes the ability to select &quot;multiple&quot; items, by setting the [selectionMulti](#attr_selectionMulti)
 attribute (enabled using browser multi-select click modifier, i.e. &quot;Cmd&quot; key on Mac OSX or &quot;Ctrl&quot; key on Windows &#x2F; Linux).

 Additionally, a &quot;range&quot; selection capability is provided by using the browser range selector click key modifier,
 specifically the Shift key on most systems.

 Specific attributes are provided that can be read for current selections, including the ATTRS [selectedRows](#attr_selectedRows),
 [selectedRecords](#attr_selectedRecords) and [selectedCells](#attr_selectedCells).

 @module DataTable
 @submodule Selection
 @class Y.DataTable.Selection
 @extends Y.DataTable
 @author Todd Smith
 @version 1.0.0
 @since 3.6.0
 **&#x2F;
function DtSelection() {}

DtSelection.ATTRS = {
    &#x2F;**
     * Node for the most recent &quot;highlighted&quot; item, either TD or TR
     * @attribute highlighted
     * @type {Node}
     * @default null
     *&#x2F;
    highlighted : {
        value:      null,
        validator:  function(v){ return (v instanceof Y.Node) || v === null; }
    },

    &#x2F;**
     * Node for the most recent &quot;selected&quot; item, either TD or TR
     * @attribute selected
     * @type {Node}
     * @default null
     *&#x2F;
    selected:{
        value:      null,
        validator:  function(v){ return (v instanceof Y.Node) || v === null; }
    },

    &#x2F;**
     * Set the current mode for highlighting, either for a single TD (as &quot;cell&quot;) or for a
     * full TR (as &quot;row&quot;)
     * @attribute highlightMode
     * @type {String}
     * @default &#x27;cell&#x27;
     *&#x2F;
    highlightMode:{
        value:      null,
        setter:     &#x27;_setHighlightMode&#x27;,
        validator:  function(v){
            if (!Y.Lang.isString(v)) return false;
            return (v === null || v === &#x27;cell&#x27; || v ===&#x27;row&#x27; ) ? true : false;
        }
    },

    &#x2F;**
     * Set the current mode for indicating selections, either for a single TD (as &quot;cell&quot;) or for a
     * full TR (as &quot;row&quot;)
     * @attribute highlightMode
     * @type {String}
     * @default &#x27;cell&#x27;
     *&#x2F;
    selectionMode:{
        value:      null,
        setter:     &#x27;_setSelectionMode&#x27;,
        validator:  function(v){
            if (!Y.Lang.isString(v)) return false;
            return (v === null || v === &#x27;cell&#x27; || v ===&#x27;row&#x27; ) ? true : false;
        }
    },

    &#x2F;**
     * Readonly attribute which returns the currently selected TR&#x27;s
     * @attribute selectedRows
     * @type {Array}
     * @readonly
     * @default []
     *&#x2F;
    selectedRows: {
        value:      [],
        readOnly:   true,
        validator:  Y.Lang.isArray,
        getter:     &#x27;_getSelectedRows&#x27;
        &#x2F;&#x2F;setter:     &#x27;_setSelectedRows&#x27;
    },

    &#x2F;**
     * Attribute that either sets the current &quot;selected&quot; records (by entering an array of DataTable record
     *  indices) or returns an array of &quot;selected&quot; records based on the recent selections.
     *
     * Note, this attribute differs from &#x60;selectedRows&#x60; in that it operates on &quot;records&quot; and NOT TR&#x27;s
     *
     * @attribute selectedRecords
     * @type {Array}
     * @default []
     *&#x2F;
    selectedRecords: {
        value:      [],
        validator:  Y.Lang.isArray,
        setter:     &#x27;_setSelectedRecords&#x27;,
        getter:     &#x27;_getSelectedRecords&#x27;
    },

    &#x2F;**
     * Attribute that sets the initially selected cells TD&#x27;s or returns the currently selected TD&#x27;s.  For
     *  setting selected cells, the attribute is assumed to be an array of cell objects in {record,column}
     *  format (See [_setSelectedCells](#method__setSelectedCells) ).
     *
     * @attribute selectedCells
     * @type {Array}
     * @default []
     *&#x2F;
    selectedCells: {
        value:      [],
        validator:  Y.Lang.isArray,
        setter:     &#x27;_setSelectedCells&#x27;,
        getter:     &#x27;_getSelectedCells&#x27;
    },

    &#x2F;**
     * Flag to allow either single &quot;selections&quot; (false) or multiple selections (true).
     * For Macintosh OSX-type systems the modifier key &quot;Cmd&quot; is held for multiple selections,
     *  and for Windows or Linux type systems the modifier key is &quot;Ctrl&quot;.
     * @attribute selectionMulti
     * @type {Boolean}
     * @default false
     *&#x2F;
    selectionMulti: {
        value:      false,
        setter:     &#x27;_setSelectionMulti&#x27;,
        validator:  Y.Lang.isBoolean
    }

};


Y.mix( DtSelection.prototype, {

    &#x2F;**
     * @property _selections
     * @type Array
     * @default null
     * @static
     * @protected
     *&#x2F;
    _selections: null,

    &#x2F;**
     * Holder for the classname for the &quot;highlight&quot; TR or TD
     * @property _classHighlight
     * @type String
     * @default null
     * @static
     * @protected
     *&#x2F;
    _classHighlight: null,

    &#x2F;**
     * Holder for the classname for the &quot;selected&quot; TR or TD
     * @property _classSelected
     * @type String
     * @default null
     * @static
     * @protected
     *&#x2F;
    _classSelected: null,

    &#x2F;**
     * Holder for the most recent &quot;click&quot; event modifier keys from last click,
     *  used for assessing &quot;multi&quot; selections.
     *
     * Contains properties;  altKey, ctrlKey, shiftKey, metaKey, button and which
     *
     * Filled initially by .initializer and on each Table &quot;click&quot;.
     *
     * @property _clickModifiers
     * @type Object
     * @default null
     * @static
     * @protected
     *&#x2F;
    _clickModifiers: null,

&#x2F;&#x2F;------------------------------------------------------------------------------------------------------
&#x2F;&#x2F;        L I F E C Y C L E    M E T H O D S
&#x2F;&#x2F;------------------------------------------------------------------------------------------------------

    &#x2F;**
     * Initializes and sets initial bindings for the datatable-selection module
     * @method initializer
     * @protected
     *&#x2F;
    initializer: function(){
        this._bindSelector();
    },

    &#x2F;**
     * Destructor to clean up bindings.
     * @method destructor
     * @protected
     *&#x2F;
    destructor: function () {
        this._unbindSelector();
    },



&#x2F;&#x2F;------------------------------------------------------------------------------------------------------
&#x2F;&#x2F;        P U B L I C     M E T H O D S
&#x2F;&#x2F;------------------------------------------------------------------------------------------------------

    &#x2F;**
     * Method to enable the datatable-selection module
     * @method disableSelection
     * @public
     *&#x2F;
    enableSelection: function(){
        this.disableSelection();
        this._bindSelector();
    },

    &#x2F;**
     * Method to disable the datatable-selection module (cleans up listeners and user interface).
     * @method disableSelection
     * @public
     *&#x2F;
    disableSelection: function(){
        this.clearAll();
        this._unbindSelector();
    },

    &#x2F;**
     * Returns the Column object (from the original &quot;columns&quot;) associated with the input TD Node.
     * @method getColumnByTd
     * @param {Node} cell Node of TD for which column object is desired
     * @return {Object} column The column object entry associated with the desired cell
     * @public
     *&#x2F;
    getColumnByTd:  function(cell){
        var colName = this.getColumnNameByTd(cell);
        return (colName) ? this.getColumn(colName) : null;
    },


    &#x2F;**
     * Returns the column &quot;key&quot; or &quot;name&quot; string for the requested TD Node
     * @method getColumnNameByTd
     * @param {Node} cell Node of TD for which column name is desired
     * @return {String} colName Column name or key name
     * @public
     *&#x2F;
    getColumnNameByTd: function(cell){
        var classes = cell.get(&#x27;className&#x27;).split(&quot; &quot;),
            regCol  = new RegExp( this.getClassName(&#x27;col&#x27;) + &#x27;-(.*)&#x27;);

        var colName;
        Y.Array.some(classes,function(item){
            var colmatch =  item.match(regCol);
            if ( colmatch &amp;&amp; Y.Lang.isArray(colmatch) &amp;&amp; colmatch[1] ) {
                colName = colmatch[1];
                return true;
            }
        });

        return colName || null;
    },

    &#x2F;**
     * Utility method that will return all selected TD Nodes for the current &quot;selected&quot; set.
     * If selections include a TR row, all child TD&#x27;s from the row are included.
     *
     * @method getSelectedTds
     * @return {Array} tds Array of selected TD&#x27;s as Nodes
     * @public
     *&#x2F;
    getSelectedTds: function(){
        var tds = [];
        Y.Array.each(this._selections,function(item){
            if ( item.get(&#x27;tagName&#x27;).toLowerCase() === &#x27;td&#x27; )
                tds.push( item );
            else if ( item.get(&#x27;tagName&#x27;).toLowerCase() === &#x27;tr&#x27; ) {
                var tdNodes = item.all(&quot;td&quot;);
                if ( tdNodes )
                    tdNodes.each(function(item){ tds.push( item )});
            }
        });
        return tds;
    },

    &#x2F;**
     * Removes all &quot;selected&quot; classes from DataTable and resets internal selections counters and &quot;selected&quot; attribute.
     * @method clearSelections
     * @public
     *&#x2F;
    clearSelections: function(){
        this._selections = [];
        this.set(&#x27;selected&#x27;,null);
        this._clearAll(this._classSelected);
    },

    &#x2F;**
     * Removes all &quot;highlight&quot; classes from DataTable and resets &#x60;highlighted&#x60; attribute.
     * @method clearHighlighted
     * @public
     *&#x2F;
    clearHighlighted: function(){
        this.set(&#x27;highlighted&#x27;,null);
        this._clearAll(this._classHighlight);
    },

    &#x2F;**
     * Removes all highlighting and selections on the DataTable.
     * @method clearAll
     * @public
     *&#x2F;
    clearAll: function(){
        this.clearSelections();
        this.clearHighlighted();
    },

&#x2F;&#x2F;------------------------------------------------------------------------------------------------------
&#x2F;&#x2F;        P R I V A T E    M E T H O D S
&#x2F;&#x2F;------------------------------------------------------------------------------------------------------

    &#x2F;**
     * Cleans up listener event handlers and static properties.
     * @method _unbindSelector
     * @private
     *&#x2F;
    _unbindSelector: function(){

        Y.Array.each( this._eventHandles.selector,function(item){
            item.detach();
        });
        this._eventHandles.selector = null;

        if ( this._eventHandles.selectorSelect )
            this._eventHandles.selectorSelect.detach();
        this._eventHandles.selectorSelect = null;

        this._clickModifiers = null;

    },

    &#x2F;**
     * Sets listeners and initial class names required for this &quot;datatable-selector&quot; module
     *
     * Note:  Delegated &quot;click&quot; listeners are defined in _setSelectedMode and _setHightlightMode methods
     *
     * @method _bindSelector
     * @private
     *&#x2F;
    _bindSelector: function(){
        this._selections = [];
        this._eventHandles.selector = [];
        this._eventHandles.selector.push( this.on(&#x27;highlightedChange&#x27;,this._highlightChange) );
        this._eventHandles.selector.push( this.on(&#x27;selectedChange&#x27;,this._selectedChange) );

        &#x2F;&#x2F; set CSS classes for highlighting and selected,
        &#x2F;&#x2F;    currently as  &quot;.yui3-datatable-sel-highlighted&quot; and &quot;.yui3-datatable-sel-selected&quot;
        this._classHighlight = this.getClassName(&#x27;sel&#x27;,&#x27;highlighted&#x27;);
        this._classSelected  = this.getClassName(&#x27;sel&#x27;,&#x27;selected&#x27;);

        &#x2F;&#x2F; track click modifier keys from last click, this is the tempalte
        this._clickModifiers = {
            ctrlKey:null, altKey:null, metaKey:null, shiftKey:null, which:null, button:null
        };
    },

    &#x2F;**
     * Method that updates the &quot;highlighted&quot; classes for the selection and unhighlights the prevVal
     * @method _highlightChange
     * @param o
     * @private
     *&#x2F;
    _highlightChange: function(o) {
        var tar = this._processNodeAction(o,&#x27;highlight&#x27;,true);
    },

    &#x2F;**
     * Method that updates the &quot;selected&quot; classes for the selection and un-selects the prevVal.
     * This method works with multiple selections (via ATTR &#x60;selectionMulti&#x60; true) by pushing
     * the current selection to the this._selections property.
     *
     * @method _selectedChange
     * @param o
     * @private
     *&#x2F;
    _selectedChange: function(o){
        &#x2F;&#x2F; Evaluate a flag to determine whether previous selections should be cleared or &quot;kept&quot;
        var keepPrev, keepRange;
        if ( Y.UA.os.search(&#x27;macintosh&#x27;) === 0 )
            keepPrev =  this.get(&#x27;selectionMulti&#x27;) === true &amp;&amp; this._clickModifiers.metaKey === true;
         else
            keepPrev =  this.get(&#x27;selectionMulti&#x27;) === true &amp;&amp; this._clickModifiers.ctrlKey === true;

        keepRange = this.get(&#x27;selectionMulti&#x27;) === true &amp;&amp; this._clickModifiers.shiftKey === true;

        &#x2F;&#x2F; clear any SHIFT selected text first ...
        this._clearDOMSelection();

        &#x2F;&#x2F; if not-multi mode and more than one selection, clear them first ...
        if ( !keepPrev &amp;&amp; !keepRange &amp;&amp; this._selections.length&gt;1 ) this.clearSelections();

        if ( keepRange ) {

            this._processRange(o);

        }  else {

            &#x2F;&#x2F; Process the action ... updating &#x27;select&#x27; class
            var tar = this._processNodeAction(o,&#x27;select&#x27;, !keepPrev );

            if ( !keepPrev ) this._selections = [];
            this._selections.push(tar);

        }

        this.fire(&#x27;selected&#x27;,{
            ochange: o,
            record: this.getRecord(o.newVal)
        });

    },

    &#x2F;**
     * Called when a &quot;range&quot; selection is detected (i.e. SHIFT key held during click) that selects
     * a range of TD&#x27;s or TR&#x27;s (depending on [selectionMode](#attr_selectionMode) setting.
     *
     * @method _processRange
     * @param {Node} o Last clicked TD of range selection
     * @private
     *&#x2F;
    _processRange: function(o) {
        var tarNew  = o.newVal,
            tarPrev = o.prevVal || null;

        if ( tarNew &amp;&amp; tarPrev ) {
            var newRec  = this.getRecord(tarNew),
                newRecI = this.data.indexOf(newRec),
                newCol  = this.getColumnNameByTd(tarNew),
                newColI = this.get(&#x27;columns&#x27;).indexOf( this.getColumn(newCol)),
                prevRec  = this.getRecord(tarPrev),
                prevRecI = this.data.indexOf(prevRec),
                prevCol  = this.getColumnNameByTd(tarPrev),
                prevColI = this.get(&#x27;columns&#x27;).indexOf( this.getColumn(prevCol));

            &#x2F;&#x2F; Calculate range offset ... delCol (horiz) and delRow (vertically)
            var delCol = newColI - prevColI,
                delRow = newRecI - prevRecI;

            &#x2F;&#x2F; if we have valid deltas, update the range cells.
            if ( delCol !== null &amp;&amp; delRow !== null) {

                if (Y.Lang.isArray(this._selections) ) {
                    this.clearSelections();
                }

                &#x2F;&#x2F; Select a range of CELLS (i.e. TD&#x27;s) ...
                if ( this.get(&#x27;selectionMode&#x27;) === &#x27;cell&#x27; ) {
                    var coldir = (delCol&lt;0) ? -1 : 1,
                        rowdir = (delRow&lt;0) ? -1 : 1,
                        cell = tarPrev;

                    for(var j=0; j&lt;=Math.abs(delRow); j++)
                        for(var i=0; i&lt;=Math.abs(delCol); i++) {
                            cell = this.getCell(tarPrev,[rowdir*(j),coldir*(i)]);
                            if (cell) {
                                cell.addClass(this._classSelected);
                                this._selections.push(cell);
                            }
                        }
                &#x2F;&#x2F; Select a range of ROWS (i.e. TR&#x27;s)
                } else if ( this.get(&#x27;selectionMode&#x27;) === &#x27;row&#x27; ) {

                    var rowdir = (delRow&lt;0) ? -1 : 1,
                        tr = this.getRow(prevRecI);

                    for(var j=0; j&lt;=Math.abs(delRow); j++) {
                        tr = this.getRow(prevRecI+rowdir*(j));
                        if (tr) {
                            tr.addClass(this._classSelected);
                            this._selections.push(tr);
                        }
                    }

                }

            }

        }

    },

    _clearDOMSelection: function(){
        var sel = (Y.config.win.getSelection) ? Y.config.win.getSelection() : (Y.config.doc.selection) ? Y.config.doc.selection : null;
        if ( sel &amp;&amp; sel.empty ) sel.empty();    &#x2F;&#x2F; works on chrome
        if ( sel &amp;&amp; sel.removeAllRanges ) sel.removeAllRanges();    &#x2F;&#x2F; works on FireFox
    },

    &#x2F;**
     * @event selected
     * @param {Object} obj Return object
     * @param {Object} obj.ochange Change event object passed from attribute &#x27;selected&#x27;
     * @param {Object} obj.record DataTable record (Y.Model) instance for the selection
     *&#x2F;

    &#x2F;**
     * Returns the current &quot;raw&quot; settings of selections (includes multiple selections)
     * @method _getSelected
     * @return {Array} selections Array of selected TR&#x27;s and&#x2F;or TD&#x27;s
     * @private
     *&#x2F;
    _getSelectedRows: function(){
        var trs = [];
        Y.Array.each(this._selections,function(item){
            var tr = ( item.get(&#x27;tagName&#x27;).toLowerCase() === &#x27;tr&#x27; ) ? item : item.ancestor(&#x27;tr&#x27;);
            &#x2F;&#x2F; if and only if, it&#x27;s a TR and not in &quot;trs&quot; array ... then add it
            if ( tr.get(&#x27;tagName&#x27;).toLowerCase() === &#x27;tr&#x27; &amp;&amp; trs.indexOf(tr) === -1)
                trs.push(tr);
        });
        return trs;
    },

    &#x2F;**
     * Getter method that returns an Array of the selected cells in {record,column} coordinate format.
     * If rows or TR elements were selected, it adds all of the row&#x27;s child TD&#x27;s.
     *
     * @method _getSelectedCells
     * @return {Array} cells The selected cells in {record:, column:} format
     * @param {Model} cells.record Record for this cell as a Y.Model
     * @param {Object} cells.column Column for this cell defined in original &quot;columns&quot; DataTable attribute
     * @private
     *&#x2F;
    _getSelectedCells: function(){
        var cells = [], td;
        Y.Array.each(this._selections,function(item){
            if (!item) return;
            if ( item.get(&#x27;tagName&#x27;).toLowerCase() === &#x27;td&#x27; )
                cells.push( {record:this.getRecord(item), column:this.getColumnByTd(item) } );
            else if ( item.get(&#x27;tagName&#x27;).toLowerCase() === &#x27;tr&#x27; ) {
                var tdNodes = item.all(&quot;td&quot;);
                if ( tdNodes )
                    tdNodes.each(function(item){
                        cells.push( {record:this.getRecord(item), column:this.getColumnByTd(item) } )
                    },this);
            }
        },this);
        return cells;
    },


    &#x2F;**
     * Setter method for attribute &#x60;selectedCells&#x60; that takes an array of cells as input and sets them
     * as the current selected set with appropriate visual class.
     *
     * @method _setSelectedCells
     * @param {Array} val The desired cells to set as selected, in {record:,column:} format
     * @param {String|Number} val.record Record for this cell as either record index or record clientId
     * @param {String|Number} val.column Column for this cell as either the column index or &quot;key&quot; or &quot;name&quot;
     * @return {Array}
     * @private
     *&#x2F;
    _setSelectedCells: function(val){
        this._selections = [];
        if ( Y.Lang.isArray(val) &amp;&amp; this.data.size() &gt; val.length ) {
            Y.Array.each(val,function(item) {
                var row, col, td;
                if ( item.record ) row = this.getRow( item.record );
                if ( item.column ) col = this.getColumn(item.column);

                if ( row &amp;&amp; col ) {
                    var ckey = col.key || col.name;
                    if ( ckey ) {
                        td = row.one(&#x27;.&#x27;+this.getClassName(&#x27;col&#x27;)+&#x27;-&#x27;+ckey);
                        this._selections.push(td);
                        td.addClass(this._classSelected);
                    }
                }

            },this);
        }
        return val;
    },


    &#x2F;**
     * A setter method for attribute &#x60;selectedRecords&#x60; that takes as input an array of desired DataTable
     * record indices to be &quot;selected&quot;, clears existing selections and sets the &quot;selected&quot; records and
     * highlights the TR&#x27;s
     *
     * @method _setSelectedRecords
     * @param val {Array} recIndices Array of record indices desired to be set as selected.
     * @return {Array} records Array of DataTable records (Y.Model) for each selection chosen
     * @private
     *&#x2F;
    _setSelectedRecords: function(val){
        this._selections = [];
        if ( Y.Lang.isArray(val) &amp;&amp; this.data.size() &gt; val.length ) {
            Y.Array.each(val,function(item){
                var tr = this.getRow(item);
                if ( tr ) {
                    this._selections.push( tr );
                    tr.addClass(this._classSelected);
                }
            },this);
        }
        return val;
    },


    &#x2F;**
     * A getter method for the &#x60;selectedRecords&#x60; attribute that returns an array of DataTable records (Y.Model)
     *  based on the current &quot;selected&quot; items, either TR&#x27;s or TD&#x27;s.
     *
     *  If TD&#x27;s were selected it converts them to their base record.
     *
     * @method _getSelectedRecords
     * @return {Array} records Array of records from the DataTable based on the selected items
     * @private
     *&#x2F;
    _getSelectedRecords: function(){
        var rows = this._getSelectedRows() || [],
            recs = [];
        Y.Array.each(rows,function(tr){
            if ( tr ) recs.push(this.getRecord(tr));
        },this);
        return recs;
    },

    &#x2F;**
     * Method used to derive from the clicked selection, either the TR or TD of the selection, and
     * returns the current &#x60;selectionMode&#x60; or &#x60;highlightMode&#x60; Node (based on the setting of prefix).
     *
     * This method adds the required class, and if erasePrev is true, removes the class from the prior setting.
     *
     * @method _processNodeAction
     * @param {Object} o Attribute change event object
     * @param {String} prefix
     * @param {Boolean} erasePrev
     * @return {Node} node Returned target Y.Node, either TR or TD based upon current &#x60;selectionMode&#x60; or &#x60;highlightMode&#x60;
     * @private
     *&#x2F;
    _processNodeAction: function(o, prefix, erasePrev ){
        var tar = o.newVal,
            tarNew, tarPrev, modeName, className;

        if ( prefix === &#x27;highlight&#x27;) {
            modeName  = prefix + &#x27;Mode&#x27;;
            className = this._classHighlight;
        } else if ( prefix === &#x27;select&#x27; ) {
            modeName  = &#x27;selectionMode&#x27;;
            className = this._classSelected;
        }

        if ( this.get(modeName) == &quot;cell&quot; ) {
            tarNew  = tar || null;
            tarPrev = o.prevVal || null;
        } else if ( this.get(modeName) == &quot;row&quot; ) {
            if ( tar ) {
                tarNew = (tar.get(&#x27;tagName&#x27;).search(&#x2F;td&#x2F;i) === 0 ) ? tar.ancestor(&#x27;tr&#x27;) : ( tar.get(&#x27;tagName&#x27;).search(&#x2F;tr&#x2F;i) === 0 ) ? tar : null ;
            }
            tarPrev = o.prevVal;
            if (tarPrev)
                tarPrev = (tarPrev.get(&#x27;tagName&#x27;).search(&#x2F;td&#x2F;i) === 0 ) ? tarPrev.ancestor(&#x27;tr&#x27;) : ( tarPrev.get(&#x27;tagName&#x27;).search(&#x2F;tr&#x2F;i) === 0 ) ? tarPrev : null ;
        }

        if ( tarPrev &amp;&amp; erasePrev )  tarPrev.removeClass(className);
        if ( tarNew ) tarNew.addClass(className);

        return tarNew;
    },


    &#x2F;**
     * Method removes the specified &#x60;type&#x60; class from all nodes within the TBODY data node.
     * @method _clearAll
     * @param {String} type Class name to remove from all nodes attached to TBODY DATA
     * @private
     *&#x2F;
    _clearAll: function(type){
        var nodes = this.get(&#x27;boundingBox&#x27;).one(&quot;.&quot;+this.getClassName(&#x27;data&#x27;));
        if ( nodes )
            nodes.all(&#x27;.&#x27;+type).removeClass(type);
    },

    &#x2F;**
     * Setter for &#x60;highlightMode&#x60; attribute, removes prior event handle (if exists) and defines
     * a new delegated &quot;mouseover&quot; handler that updates the &#x60;highlighted&#x60; attribute.
     *
     * A change to this setting clears all prior highlighting.
     *
     * @method _setHighlightMode
     * @param val
     * @return {*}
     * @private
     *&#x2F;
    _setHighlightMode: function(val){
        if ( this._eventHandles.selectorHighlight ) this._eventHandles.selectorHighlight.detach();
        this._eventHandles.selectorHighlight = this.delegate(&quot;mouseover&quot;,function(e){
                var tar = e.currentTarget;
                this.set(&#x27;highlighted&#x27;,tar);
            },&quot;tr td&quot;,this);

        this._clearAll(this._classHighlight);
        return val;
    },

    &#x2F;**
     * Setter for &#x60;selectionMode&#x60; attribute, removes prior event handle (if exists) and defines
     * a new delegated &quot;click&quot; handler that updates the &#x60;selected&#x60; attribute.
     *
     * A change to this setting clears all prior selections.
     *
     * @method _setSelectionMode
     * @param val
     * @return {*}
     * @private
     *&#x2F;
    _setSelectionMode: function(val){
        var oSelf = this;
        if ( this._eventHandles.selectorSelect ) this._eventHandles.selectorSelect.detach();
        this._eventHandles.selectorSelect = this.delegate(&quot;click&quot;,function(e){
                var tar = e.currentTarget;

                e.halt(true);

                oSelf._clickModifiers = {
                    ctrlKey:  e.ctrlKey,
                    altKey:   e.altKey,
                    metaKey:  e.metaKey,
                    shiftKey: e.shiftKey,
                    which:    e.which,
                    button:   e.button
                };

                oSelf.set(&#x27;selected&#x27;,tar);

            },&quot;tr td&quot;,oSelf);
        this._clearAll(this._classSelected);
        return val;
    }

});

Y.DataTable.Selection = DtSelection;
Y.Base.mix(Y.DataTable, [Y.DataTable.Selection]);


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
